<!DOCTYPE html><html class="html-loading"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Java注解和Java反射 | Howard-Blogs</title><meta name="author" content="Howard Yin"><meta name="keywords" content><meta name="description" content><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/Annie.css"><script src="/js/jquery.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script src="/js/leancloud.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css"></head><body><div id="preloader"><div class="pre-container"><div class="spinner"><div class="double-bounce1"></div><div class="double-bounce2"></div></div></div></div><header class="fixbackground" data-img-mode="normal" data-normal-src="/img/1.jpg" data-random-max="110" data-random-src="https://sariay.github.io/Random-img/"><div class="mask"><div class="h-header"><div id="logo"><a href="/"><img src="/img/logo.png" alt="Logo"></a></div><div id="navigation-show"><ul><li class="menu-home"><a href="/" class="menu-item-home">主页</a></li><li class="menu-archive"><a href="/archives" class="menu-item-archive">归档</a></li><li class="menu-categories"><a href="/categories" class="menu-item-categories">分类</a></li><li class="menu-tags"><a href="/tags" class="menu-item-tags">标签</a></li><li class="menu-about"><a href="/about" class="menu-item-about">关于</a></li><li class="menu-gallery"><a href="/gallery" class="menu-item-gallery">相册</a></li></ul></div></div><div class="h-body"><p class="motto"></p></div><div class="h-footer"><a href="javascript:;" id="read-more"><i class="fa fa-angle-double-down" aria-hidden="true"></i></a><style type="text/css">.header-date{font-size:1.6rem;color:#fff;position:absolute;bottom:5px;right:1rem;writing-mode:tb-rl}.header-date a{border-bottom:none}@media only screen and (max-width:768){.header-date{font-size:1rem}}</style><div class="header-date"><a href="https://time.is/Beijing" id="time_is_link" rel="nofollow"></a> <span id="Beijing_z43d"></span></div><script src="//widget.time.is/zh.js"></script><script>time_is_widget.init({Beijing_z43d:{template:"DATE",date_format:"year年 monthnum月 dnum日"}})</script></div></div></header><div id="navigation-hide"><div id="progress-bar"></div><div id="progress-percentage"><h1>0.0%</h1></div><div class="toc-switch"><span class="switch-button">目录</span></div><p>当前文章&nbsp;:&nbsp;《Java注解和Java反射》</p><a class="nav-trigger"><span></span></a></div><nav class="nav-container" id="cd-nav"><div class="nav-header"><h3>Navigation</h3><a href="javascript:;" class="nav-close"></a></div><div class="nav-body"><ul><li class="menu-home"><a href="/" class="menu-item-home">主页</a></li><li class="menu-archive"><a href="/archives" class="menu-item-archive">归档</a></li><li class="menu-categories"><a href="/categories" class="menu-item-categories">分类</a></li><li class="menu-tags"><a href="/tags" class="menu-item-tags">标签</a></li><li class="menu-about"><a href="/about" class="menu-item-about">关于</a></li><li class="menu-gallery"><a href="/gallery" class="menu-item-gallery">相册</a></li></ul></div><div class="nav-footer"><ul><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-github"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-pinterest"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-instagram"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-twitter"></i></a></li><li><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li></ul></div></nav><main><div class="layout-toc"><div id="layout-toc"><div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div></div></div><script src="/plugin/toc/katelog.min.js"></script><div class="layout-post"><div id="layout-post"><div class="article-title"><i class="fa fa-paper-plane-o" aria-hidden="true"></i> <a href="/编程语言/Java/注解.html" itemprop="url">Java注解和Java反射</a></div><div class="article-meta"><span><i class="fa fa-calendar"></i> 发布于 <a href="/编程语言/Java/注解.html" itemprop="url"><time datetime="2019-10-06T15:07:24.000Z" itemprop="datePublished">2019-10-06 </time></a>&nbsp; 更新于 <a href="/编程语言/Java/注解.html" itemprop="url"><time datetime="2019-10-06T15:07:24.000Z" itemprop="dateUpdated">2020-06-24</time></a> </span><span><i class="fa fa-tags"></i> <a href="/tags/Java/">Java </a><a href="/tags/Spring/">Spring</a></span></div><div class="article-content" id="article-content"><h2 id="注解是什么"><a class="markdownIt-Anchor" href="#注解是什么"></a> 注解是什么</h2><p>Java注解（Annotation）又称Java注解，是JDK5.0引入的一种注释机制。</p><p>Java语言中的类、方法、变量、参数和包等都可以被注解。和Javadoc不同，Java注解<strong>可以通过反射获取注解内容</strong>。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注解内容，在运行时可以获取到注解内容。当然它也支持自定义Java注解。</p><h3 id="一句话概括"><a class="markdownIt-Anchor" href="#一句话概括"></a> 一句话概括</h3><p>在实例化之前就给类贴上标签</p><h2 id="内置注解"><a class="markdownIt-Anchor" href="#内置注解"></a> 内置注解</h2><p>Java自带7种注解，3个在<code>java.lang</code>中，4个在<code>java.lang.annotation</code>中。</p><h3 id="在javalang中的注解"><a class="markdownIt-Anchor" href="#在javalang中的注解"></a> 在<code>java.lang</code>中的注解</h3><p><code>java.lang</code>中的注解都是作用于代码的，有以下几种：</p><ul><li><code>@Override</code>：检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li><code>@Deprecated</code>：标记过时方法。如果使用该方法，会报编译警告。</li><li><code>@SuppressWarnings</code>：指示编译器去忽略注解中声明的警告。</li></ul><p>从 Java 7 开始，额外添加了 3 个注解：</p><ul><li><code>@SafeVarargs</code>：Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li><code>@FunctionalInterface</code>：Java 8 开始支持，标识一个匿名函数或函数式接口（用于函数式编程，经它标记的函数式接口可以很容易转换为 Lambda 表达式）。</li></ul><h3 id="在javalangannotation中的注解"><a class="markdownIt-Anchor" href="#在javalangannotation中的注解"></a> 在<code>java.lang.annotation</code>中的注解</h3><p>在<code>java.lang.annotation</code>中的是作用于其他注解的注解，这些注解是给程序员用来构造自定义注解的。<code>java.lang.annotation</code>中的注解又称为<strong>元注解</strong>。</p><ul><li><code>@Retention</code>：标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li><code>@Documented</code>：标记这些注解是否包含在用户文档中。</li><li><code>@Target</code>：标记这个注解应该是哪种 Java 成员。</li><li><code>@Inherited</code>：标记这个注解是继承于哪个注解类(默认注解并没有继承于任何子类)</li></ul><p>从 Java 8 开始，额外添加了 1 个注解：</p><ul><li><code>@Repeatable</code>：Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><h2 id="自定义注解"><a class="markdownIt-Anchor" href="#自定义注解"></a> 自定义注解</h2><h3 id="定义注解"><a class="markdownIt-Anchor" href="#定义注解"></a> 定义注解</h3><p>下面是几个自定义注解的示例，下面几节都将围绕着这几个注解展开。</p><h4 id="不带参数的注解"><a class="markdownIt-Anchor" href="#不带参数的注解"></a> 不带参数的注解</h4><p>不带参数的注解可以看作是一个纯粹的标记，标明被注解物“是什么”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExampleAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="带参数的注解"><a class="markdownIt-Anchor" href="#带参数的注解"></a> 带参数的注解</h4><p>带参数的注解可以看作是用来标明被注解物“有何属性”。注解的没有参数只有接口方法，获取注解的变量都是以调用这些方法的方式完成的；注解的接口方法后边可以跟上一个<code>default</code>用来指定方法默认的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExampleAnnotation1 &#123;</span><br><span class="line">    <span class="function">String <span class="title">exampleProp</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">exampleProp1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面这个注解在调用时要写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExampleAnnotation</span>1(exampleProp=<span class="string">"哈哈哈"</span>,exampleProp1=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>而如果注解的参数只有一个，则可以省去参数列表，例如下面这个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExampleAnnotation2 &#123;</span><br><span class="line">    <span class="function">String <span class="title">exampleProp</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用时就可以写成这两种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExampleAnnotation</span>1(exampleProp=<span class="string">"哈哈哈"</span>)</span><br><span class="line"><span class="meta">@ExampleAnnotation</span>1(<span class="string">"哈哈哈"</span>)</span><br></pre></td></tr></table></figure><p>另外有一点需要注意：全部属性都有默认值的注解在调用时可以省去注解值但不能省去括号。</p><h3 id="元注解含义解释"><a class="markdownIt-Anchor" href="#元注解含义解释"></a> 元注解含义解释</h3><h4 id="retentionretentionpolicyruntime"><a class="markdownIt-Anchor" href="#retentionretentionpolicyruntime"></a> <code>@Retention(RetentionPolicy.RUNTIME)</code></h4><p>Retention 的英文意为保留期的意思。标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</p><p>它是一个有参数的注解，后面紧跟的括号中需要有一个参数，其取值有如下几种：</p><ul><li><code>RetentionPolicy.SOURCE</code> 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</li><li><code>RetentionPolicy.CLASS</code> 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。</li><li><code>RetentionPolicy.RUNTIME</code> 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。</li></ul><p>因此，上面的这个自定义注释<code>ExampleAnnotation</code>可以保留到程序运行时。</p><h4 id="documented"><a class="markdownIt-Anchor" href="#documented"></a> <code>@Documented</code></h4><p>带有这个标记的注解中的元素将被包含到Javadoc中。ez，不解释</p><h4 id="targetelementtypetype"><a class="markdownIt-Anchor" href="#targetelementtypetype"></a> <code>@Target(ElementType.TYPE)</code></h4><p>Target 是目标的意思，@Target 指定了注解可以运用的地方。这个元注解限定了定义的注解可以注解的范围。</p><p>它是一个有参数的注解，后面紧跟的括号中需要有一个参数，其取值有如下几种：</p><ul><li><code>ElementType.ANNOTATION_TYPE</code>：可以给一个注解进行注解</li><li><code>ElementType.TYPE</code>：可以给一个类型进行注解，比如类、接口、枚举</li><li><code>ElementType.CONSTRUCTOR</code>：可以给类的构造方法进行注解</li><li><code>ElementType.METHOD</code>：可以给类方法进行注解</li><li><code>ElementType.PARAMETER</code>：可以给一个方法内的参数进行注解</li><li><code>ElementType.FIELD</code>：可以给属性进行注解（类成员变量）</li><li><code>ElementType.LOCAL_VARIABLE</code>：可以给局部变量进行注解</li><li><code>ElementType.PACKAGE</code>：可以给一个包进行注解</li></ul><p>因此，上面的元注解表示<code>ExampleAnnotation</code>可以给一个类型进行注解。</p><h4 id="inherited"><a class="markdownIt-Anchor" href="#inherited"></a> <code>@Inherited</code></h4><p>带有<code>@Inherited</code>的注解如果用来注解的了一个类<code>A</code>，那么当<code>A</code>被继承时且继承者没有进行其他注解时，那么这个继承者也会自动带上这个注解。如下：</p><ul><li>用<code>@ExampleAnnotation</code>注解了<code>A</code>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExampleAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>再用<code>B</code>继承<code>A</code>，并且加任何其他注解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>就相当于<code>B</code>也被<code>@ExampleAnnotation</code>注解了：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExampleAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="repeatable"><a class="markdownIt-Anchor" href="#repeatable"></a> <code>@Repeatable</code></h4><p><code>@Repeatable</code>是可重复的意思，表明这个注解会多次应用。</p><ul><li>什么场景下我们需要多次应用一个注解？</li><li>当注解的值可以同时取多个，并且具体取几个还不确定时。</li></ul><p>例如某个小公司里一个人要干几个人的活：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[]  value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable</span>(Persons.class)</span><br><span class="line"><span class="meta">@interface</span> Person&#123;</span><br><span class="line">    <span class="function">String <span class="title">role</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"产品经理"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"测试"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"公关"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>或者也可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Persons</span>(&#123;<span class="string">"产品经理"</span>,<span class="string">"测试"</span>,<span class="string">"公关"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这样就能给一个对象标上数量不等的多个注解了。其中这里的<code>Persons</code>称为<strong>容器注解</strong>，专用于放其他注解。容器注解中必须有一个名叫<code>value</code>的属性，且其属性类型必须是一个被<code>@Repeatable</code>注解过的注解类型数组（注意是数组）。</p><h2 id="自定义注解的使用"><a class="markdownIt-Anchor" href="#自定义注解的使用"></a> 自定义注解的使用</h2><p>注解的使用方法包含于反射的使用方法中，见下文。</p><h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2><h3 id="反射是什么"><a class="markdownIt-Anchor" href="#反射是什么"></a> 反射是什么</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种<strong>动态获取信息</strong>以及<strong>动态调用对象方法</strong>的功能称为java语言的反射机制。</p><h3 id="反射所用到的类"><a class="markdownIt-Anchor" href="#反射所用到的类"></a> 反射所用到的类</h3><table><thead><tr><th>类</th><th>作用</th></tr></thead><tbody><tr><td>Class</td><td>代表类的实体，在运行的Java应用程序中表示类和接口</td></tr><tr><td>Field</td><td>代表类的成员变量（成员变量也称为类的属性）</td></tr><tr><td>Method</td><td>代表类的方法</td></tr><tr><td>Constructor</td><td>代表类的构造方法</td></tr></tbody></table><p>例如，现在有一个类<code>Cls</code>在包<code>com.here.is</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.here.is</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cls</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String publicField;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> privateField;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethod</span><span class="params">(String v)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">privateMethod</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cls</span><span class="params">(<span class="keyword">int</span> a,String b)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Cls</span><span class="params">(String b)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么可以进行这么一堆初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.here.is</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">"com.here.is.Cls"</span>);<span class="comment">//反射获取一个类</span></span><br><span class="line">Class&lt;?&gt; cls = Cls.class<span class="comment">//或者这样也行</span></span><br><span class="line"></span><br><span class="line">Field publicVal = cls.getField(<span class="string">"publicField"</span>);<span class="comment">//反射获取一个变量，仅限public</span></span><br><span class="line">Field privateVal = cls.getDeclaredField(<span class="string">"privateField"</span>);<span class="comment">//反射获取任意一个变量</span></span><br><span class="line"></span><br><span class="line">Method publicMeth = cls.getMethod(<span class="string">"publicMethod"</span>,String.class);<span class="comment">//反射获取一个方法，仅限public。输入方法名的后面跟上参数类型列表</span></span><br><span class="line">Method privateMeth = cls.getDeclaredMethod(<span class="string">"privateMethod"</span>,<span class="keyword">int</span>.class);<span class="comment">//反射获取任意一个方法。输入方法名的后面跟上参数类型列表</span></span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt; publicConstr = cls.getConstructor(<span class="keyword">int</span>.class,String.class);<span class="comment">//反射获取构造方法，仅限public。输入参数类型列表</span></span><br><span class="line">Constructor&lt;?&gt; publicConstr = cls.getDeclaredConstructor(String.class);<span class="comment">//反射获取任意一个构造方法。输入参数类型列表</span></span><br></pre></td></tr></table></figure><h3 id="这反射类的类方法详解"><a class="markdownIt-Anchor" href="#这反射类的类方法详解"></a> 这反射类的类方法详解</h3><h4 id="与类的获得相关的方法"><a class="markdownIt-Anchor" href="#与类的获得相关的方法"></a> 与类的获得相关的方法</h4><p>这些方法都在<code>Class</code>中：</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>forName(String className)</code></td><td>根据类名返回类的对象（静态方法）</td></tr><tr><td><code>asSubclass(Class&lt;U&gt; clazz)</code></td><td>把传递的类的对象转换成代表其子类的对象</td></tr><tr><td><code>Cast</code></td><td>把对象转换成代表类或是接口的对象</td></tr><tr><td><code>getClassLoader()</code></td><td>获得类的加载器</td></tr><tr><td><code>getClasses()</code></td><td>返回一个数组，数组中包含该类中所有公共类和接口类的对象</td></tr><tr><td><code>getDeclaredClasses()</code></td><td>返回一个数组，数组中包含该类中所有类和接口类的对象</td></tr><tr><td><code>getName()</code></td><td>获得类的完整路径名字</td></tr><tr><td><code>newInstance()</code></td><td>创建类的实例</td></tr><tr><td><code>getPackage()</code></td><td>获得类的包</td></tr><tr><td><code>getSimpleName()</code></td><td>获得类的名字</td></tr><tr><td><code>getSuperclass()</code></td><td>获得当前类继承的父类的名字</td></tr><tr><td><code>getInterfaces()</code></td><td>获得当前类实现的类或是接口</td></tr></tbody></table><h4 id="与构造和实例化相关的方法"><a class="markdownIt-Anchor" href="#与构造和实例化相关的方法"></a> 与构造和实例化相关的方法</h4><h5 id="获得构造函数"><a class="markdownIt-Anchor" href="#获得构造函数"></a> 获得构造函数</h5><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>getConstructor(Class...&lt;?&gt; parameterTypes)</code></td><td>获得该类中与参数类型匹配的公有构造方法</td></tr><tr><td><code>getConstructors()</code></td><td>获得该类的所有公有构造方法</td></tr><tr><td><code>getDeclaredConstructor(Class...&lt;?&gt; parameterTypes)</code></td><td>获得该类中与参数类型匹配的构造方法</td></tr><tr><td><code>getDeclaredConstructors()</code></td><td>获得该类所有构造方法</td></tr></tbody></table><h5 id="进行实例化"><a class="markdownIt-Anchor" href="#进行实例化"></a> 进行实例化</h5><p><code>Class</code>类中有一个<code>newInstance()</code>用于实例化，<code>Constructor</code>类中也有一个<code>newInstance()</code>方法用于实例化，用法一样（其实<code>Constructor</code>类只有这一个方法）。</p><p>上接上一节的一堆初始化，这里举几个用反射进行实例化的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通常用这个</span></span><br><span class="line">Object obj = cls.newInstance(<span class="number">1</span>,<span class="string">"哈哈哈"</span>);</span><br><span class="line">Cls c = (Cls) obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以用public的构造方法</span></span><br><span class="line">Object obj1 = publicConstr.newInstance(<span class="number">1</span>,<span class="string">"哈哈哈"</span>);</span><br><span class="line">Cls c1 = (Cls) obj1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//private的构造方法调用了setAccessible(true)之后也是可以的</span></span><br><span class="line">privateConstr.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object obj2 = privateConstr.newInstance(<span class="string">"哈哈哈"</span>);</span><br><span class="line">Cls c2 = (Cls) obj2;</span><br></pre></td></tr></table></figure><h4 id="与属性相关的方法"><a class="markdownIt-Anchor" href="#与属性相关的方法"></a> 与属性相关的方法</h4><h5 id="获得属性"><a class="markdownIt-Anchor" href="#获得属性"></a> 获得属性</h5><p><code>Class</code>类中与属性相关的方法全部是用来获得属性的。</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>getField(String name)</code></td><td>获得某个公有的属性对象</td></tr><tr><td><code>getFields()</code></td><td>获得所有公有的属性对象</td></tr><tr><td><code>getDeclaredField(String name)</code></td><td>获得某个属性对象</td></tr><tr><td><code>getDeclaredFields()</code></td><td>获得所有属性对象</td></tr></tbody></table><h5 id="操作属性"><a class="markdownIt-Anchor" href="#操作属性"></a> 操作属性</h5><p>用来操作属性的方法都在<code>Field</code>类中，<code>Field</code>类中的方法全部是用来操作属性的方法。</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>equals(Object obj)</code></td><td>属性与obj相等则返回true</td></tr><tr><td><code>get(Object obj)</code></td><td>获得obj中对应的属性值</td></tr><tr><td><code>set(Object obj, Object value)</code></td><td>设置obj中对应属性值</td></tr></tbody></table><p>上接那个实例化的例子，这里举几个用反射获取变量值和设置变量的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">publicVal.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String publicValue = (String) publicVal.get(obj);<span class="comment">//获取变量</span></span><br><span class="line">publicVal.set(obj,<span class="string">"呵呵呵"</span>);<span class="comment">//设置变量</span></span><br><span class="line"></span><br><span class="line">privateVal.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">int</span> privateValue = (<span class="keyword">int</span>) privateVal.get(obj);<span class="comment">//获取变量</span></span><br><span class="line">privateVal.set(obj,<span class="string">"2"</span>);<span class="comment">//设置变量</span></span><br></pre></td></tr></table></figure><h4 id="与方法相关的方法"><a class="markdownIt-Anchor" href="#与方法相关的方法"></a> 与方法相关的方法</h4><h5 id="获得方法"><a class="markdownIt-Anchor" href="#获得方法"></a> 获得方法</h5><p><code>Class</code>类中与方法相关的方法全部是用来获得方法的。</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>getMethod(String name, Class...&lt;?&gt; parameterTypes)</code></td><td>获得该类某个公有的方法</td></tr><tr><td><code>getMethods()</code></td><td>获得该类所有公有的方法</td></tr><tr><td><code>getDeclaredMethod(String name, Class...&lt;?&gt; parameterTypes)</code></td><td>获得该类某个方法</td></tr><tr><td><code>getDeclaredMethods()</code></td><td>获得该类所有方法</td></tr></tbody></table><h5 id="调用方法"><a class="markdownIt-Anchor" href="#调用方法"></a> 调用方法</h5><p><code>Method</code>类中只有一个方法<code>invoke(Object obj, Object... args)</code>，用于调用该对象对应的方法。</p><p>上接那个实例化的例子，这里举几个用反射调用方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">publicMeth.invoke(obj,<span class="string">"嚯嚯嚯"</span>);<span class="comment">//什么都不返回</span></span><br><span class="line">privateMeth.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">int</span> result = (<span class="keyword">int</span>) privateMeth.invoke(obj,<span class="number">3</span>);<span class="comment">//返回int</span></span><br></pre></td></tr></table></figure><h4 id="与注解相关的方法"><a class="markdownIt-Anchor" href="#与注解相关的方法"></a> 与注解相关的方法</h4><p>与注解相关的方法在<code>Class</code>、<code>Field</code>、<code>Method</code>和<code>Constructor</code>中都有：</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>getAnnotation(Class&lt;? extends Annotation&gt; annotationClass)</code></td><td>返回该类中与参数类型匹配的公有注解对象</td></tr><tr><td><code>getAnnotations()</code></td><td>返回该类所有的公有注解对象</td></tr><tr><td><code>getDeclaredAnnotation(Class&lt;? extends Annotation&gt; annotationClass)</code></td><td>返回该类中与参数类型匹配的所有注解对象</td></tr><tr><td><code>getDeclaredAnnotations()</code></td><td>返回该类所有的注解对象</td></tr></tbody></table><p>此外，在<code>Class</code>中还有两个用于判断注解类的方法：</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>isAnnotation()</code></td><td>如果这个类型是注解类型则返回true</td></tr><tr><td><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></td><td>如果这个类型是继承于<code>annotationClass</code>类型的注解类型则返回true</td></tr></tbody></table><p>那么，上接那个一个人要干几个人的活的小公司一般社员，这里举几个反射获取注解的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isAnnotation = Persons.class.isAnnotation();<span class="comment">//Persons类是注解类吗？是的。故为true</span></span><br><span class="line"><span class="keyword">boolean</span> isPresent = SuperMan.class.isAnnotationPresent(Persons.class);<span class="comment">//SuperMan有被Persons类注解吗？有的。故为true</span></span><br><span class="line">Persons superManAnnotation = SuperMan.class.getAnnotation(Persons.class);<span class="comment">//获取注解</span></span><br><span class="line">String[]values = superManAnnotation.value();<span class="comment">//获取注解的值</span></span><br></pre></td></tr></table></figure><p>再来一个方法注释的例子。例如有一方法注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTestMethod &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后我们告诉测试人员，这个<code>@MyTestMethod</code>注释的方法可以用来测试程序是否运作正常，让测试人员将其放在测试类里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperManTest</span></span>&#123;</span><br><span class="line">    <span class="meta">@MyTestMethod</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">SuperManTest1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTestMethod</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">SuperManTest2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTestMethod</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">PrivateSuperManTest1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTestMethod</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">PrivateSuperManTest2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以这么写测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SuperManTest testObj = <span class="keyword">new</span> SuperManTest();<span class="comment">//先实例化</span></span><br><span class="line">Class cls = testObj.getClass();<span class="comment">//再获取它的类</span></span><br><span class="line">Method[] methods = cls.getDeclaredMethods();<span class="comment">//再获取它的方法</span></span><br><span class="line"><span class="keyword">for</span>(Method method:methods)&#123;<span class="comment">//检查每一个方法</span></span><br><span class="line">    <span class="keyword">if</span>(method.isAnnotationPresent(MyTestMethod.class))&#123;<span class="comment">//如果有@MyTestMethod标记</span></span><br><span class="line">        <span class="keyword">try</span>&#123;<span class="comment">//那就运行它</span></span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            method.invoke(testObj,<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">//错误处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而可以运行<code>SuperManTest</code>这个类中所有打了<code>@MyTestMethod</code>注解的类，从而通过这一个个测试函数对程序进行测试。</p><p>这也就是Java中常用的测试工具JUnit的基本原理。</p><h2 id="spring中的反射与注解"><a class="markdownIt-Anchor" href="#spring中的反射与注解"></a> Spring中的反射与注解</h2><p>以 Spring Bean 为例，介绍反射在IoC中的应用。</p><p>这里只做原理上的简要介绍。</p><h3 id="以xml文件定义的bean组装"><a class="markdownIt-Anchor" href="#以xml文件定义的bean组装"></a> 以XML文件定义的Bean组装</h3><p>在 Spring 中，构成应用程序主干并<strong>由Spring IoC容器管理的对象</strong>称为bean。</p><p>——bean是一个由Spring IoC容器实例化、组装和管理的对象。</p><p>在曾经的Spring使用XML文件定义一系列Bean的组装过程。这种定义方式比较直观，并且能极大地降低代码的耦合度。</p><h4 id="bean"><a class="markdownIt-Anchor" href="#bean"></a> Bean</h4><p>Bean是一种Java对象。</p><p>根据bean规范编写出来的类，并由Bean容器生成的对象就是一个Bean。</p><h4 id="bean容器"><a class="markdownIt-Anchor" href="#bean容器"></a> Bean容器</h4><p>Bean容器，或称Spring IoC容器，主要用来管理对象和依赖，以及依赖的注入。</p><h4 id="bean规范"><a class="markdownIt-Anchor" href="#bean规范"></a> Bean规范</h4><ul><li>所有属性为private</li><li>提供默认构造方法</li><li>提供getter和setter</li><li>实现serializable接口</li></ul><h4 id="xml定义的-spring-bean-组装过程"><a class="markdownIt-Anchor" href="#xml定义的-spring-bean-组装过程"></a> XML定义的 Spring Bean 组装过程</h4><p>例如，现在有一个符合Bean标准的类<code>Cls</code>在包<code>com.here.is</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.here.is</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cls</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String aField;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAField</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aField;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAField</span><span class="params">(String aField)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aField=aField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> anotherField;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAnotherField</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> anotherField;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnotherField</span><span class="params">(String anotherField)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aField=anotherField;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后XML文件里面有这样一段定义了一个Bean的组装：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">class</span>=<span class="string">"com.here.is.Cls"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--property配置需要依赖注入的属性--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"AField"</span> <span class="attr">value</span>=<span class="string">"aVal"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"AnotherField"</span> <span class="attr">value</span>=<span class="string">"anotherVal"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，当程序初始化的时候，Spring IoC容器会执行类似下面的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">"com.here.is.Cls"</span>);<span class="comment">//获取类型</span></span><br><span class="line">Object bean = cls.newInstance();<span class="comment">//默认构造函数创建实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过解析XML获取到要注入的两个属性</span></span><br><span class="line"><span class="comment">//然后进行注入</span></span><br><span class="line">String property1 = <span class="string">"AField"</span>;</span><br><span class="line">String value1 = <span class="string">"aVal"</span></span><br><span class="line">Method method1 = cls.getMethod(<span class="string">"get"</span>+property1,value1.class);<span class="comment">//获取setter方法</span></span><br><span class="line">method1.invoke(bean,value1);<span class="comment">//进行set操作，即注入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外一个property注入过程同上</span></span><br><span class="line">String property2 = <span class="string">"AnotherField"</span>;</span><br><span class="line">String value2 = <span class="string">"aVal"</span></span><br><span class="line">Method method2 = cls.getMethod(<span class="string">"get"</span>+property2,value2.class);</span><br><span class="line">method2.invoke(bean,value2);</span><br></pre></td></tr></table></figure><h4 id="注解定义的bean组装"><a class="markdownIt-Anchor" href="#注解定义的bean组装"></a> 注解定义的Bean组装</h4><p>XML方法虽然直观，但是当工程变大了之后，XML文件变得很长，不好维护，所以后来才引入了注解方法。</p><p>注解方法的可维护性好但是耦合度比较高，是为了可维护性而对耦合性做出的妥协。</p><h5 id="注解定义的核心"><a class="markdownIt-Anchor" href="#注解定义的核心"></a> 注解定义的核心</h5><p>用注解和用XML最大的不同在于，XML是独立于代码的，而注解散布在代码中（这也是注解耦合性高的主要原因）。</p><p>XML定义的Bean组装其核心是XML解析器，对应的注解定义的核心也就是注解扫描和解析器。注解扫描器用于扫描代码内指定部分的注解，交给解析器进行分析；解析器对扫描到的注解进行解析，然后就可以和XML解析器一样进行Bean的组装了。</p><h5 id="几个重要注解"><a class="markdownIt-Anchor" href="#几个重要注解"></a> 几个重要注解</h5><ul><li><code>@Component</code>：是一个通用的Spring容器管理的单例bean组件，这个注解表示被标注的类是一个组件，将会被容器自动扫描并创建实例。它有三个拓展注解<code>@Service</code>，<code>@Controller</code>，<code>@Repository</code>。用这些注解对应用进行分层之后，就能将请求处理，义务逻辑处理，数据库操作处理分离出来，为代码解耦，也方便了以后项目的维护和开发。<ul><li><code>@Repository</code>注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。注解类作为DAO对象（数据访问对象，Data Access Objects），这些类可以直接对数据库进行操作。</li><li><code>@Controller</code>层是spring-mvc的注解，注解类进行前端请求的处理，转发，重定向。包括调用Service层的方法。</li><li><code>@Service</code>层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。</li></ul></li><li><code>@Autowired</code>：这个注解是一个针对成员变量的注解，表示被注解字段需要由程序来为其自动赋值。<ul><li><code>@Resource</code>：这个注解功能和<code>@Autowired</code>相同，但是它是JSR-250标准的注解，是属于J2EE的（<a href="https://www.cnblogs.com/leiOOlei/p/3713779.html" target="_blank" rel="noopener">它们的异同点</a>）。</li></ul></li></ul><p>上面那个Bean定义+XML就可以转化为下面这样（看，耦合了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.here.is</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(id=<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cls</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>(value=<span class="string">"aVal"</span>)</span><br><span class="line">    <span class="keyword">private</span> String aField;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAField</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aField;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAField</span><span class="params">(String aField)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aField=aField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>(value=<span class="string">"anotherVal"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> anotherField;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAnotherField</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> anotherField;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnotherField</span><span class="params">(String anotherField)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aField=anotherField;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过注解扫描和解析器处理后就会进行和上面XML一样的反射装配操作。</p></div><div id="current-post-cover" data-scr="/img/cart_cover.jpg"></div><div class="investment-container"><div class="investment-header"><div class="investment-title-1"><div class="on">相关文章</div><div>评论</div><div>分享</div></div><div class="investment-title-2"><span><a href="javascript: window.scrollTo(0, 0);">返回顶部</a> <a href="/数据库/各种数据库概述.html" title="各种数据库概述" rel="prev">&laquo;上一篇 </a><a href="/数据库/Cassandra.html" title="Cassandra简介" rel="next">下一篇&raquo;</a></span></div></div><div class="investment-content"><div class="investment-content-list"><div class="relate-post"><ul><li><div class="relate-post-text"><a class="relate-post-title" href="/编程语言/Tex/Tex历史.html" title="TEX历史">TEX历史</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 24日, 2020</p><p class="relate-post-content">参考资料参考资料 起源Knuth 最早是在一台 DEC PDP-11 上用一种叫做 SAIL 的语言编写的 TeX，尔后他和一些合作者，开始在 Stanford 大学实验一种叫做 literate programming (文学编程)...</p></div><div class="relate-post-cover"><a href="/编程语言/Tex/Tex历史.html" title="TEX历史"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="TEX历史"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/编程语言/Go/go的反射.html" title="(未完成)go的反射">(未完成)go的反射</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 四月 7日, 2020</p><p class="relate-post-content">go的反射模型在Golang实现的反射中，interface{}变量可以看作一个“pair”，“pair”中记录了实际变量的值和类型：(value, type)，value记录了变量的值，type记录了变量的类型。这个“pair”在...</p></div><div class="relate-post-cover"><a href="/编程语言/Go/go的反射.html" title="(未完成)go的反射"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="(未完成)go的反射"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/编程语言/Tex/LaTeX基础.html" title="LaTeX基础">LaTeX基础</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 四月 2日, 2020</p><p class="relate-post-content">参考资料：LaTeX vs. MiKTeX: The levels of TeXdoc 、ltxdoc 与 docstrip The levels of TeX —— TeX系统的层次结构发行版：TeX Live、MiKTeX、CTe...</p></div><div class="relate-post-cover"><a href="/编程语言/Tex/LaTeX基础.html" title="LaTeX基础"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="LaTeX基础"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/编程语言/Tex/文学编程.html" title="文学编程（Literate Programming）">文学编程（Literate Programming）</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 四月 1日, 2020</p><p class="relate-post-content">正如 Donald Ervin Knuth 所构想的那样，文学编程范型不同于传统的由计算机强加的编写程序的方式和顺序，而代之以让程序员用他们自己思维内在的逻辑和流程所要求的顺序开发程序。——维基百科graph LR foo.w...</p></div><div class="relate-post-cover"><a href="/编程语言/Tex/文学编程.html" title="文学编程（Literate Programming）"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="文学编程（Literate Programming）"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/编程语言/Tex/TeX基础.html" title="TEX基础">TEX基础</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 四月 1日, 2020</p><p class="relate-post-content">TEX命令行的使用首先，第一步当然是打开TEX命令行，如果安装了TEX：1$ tex然后会显示：12This is TeX, Version 3.14159265 (TeX Live 2019/W32TeX) (preloaded ...</p></div><div class="relate-post-cover"><a href="/编程语言/Tex/TeX基础.html" title="TEX基础"><img class="lazy" src="/img/placeholder.jpg" data-src="/编程语言/Tex/i/TeXif1.png" alt="TEX基础"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/编程语言/Tex/TeX公式Tips.html" title="TEX公式知识点拾遗">TEX公式知识点拾遗</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 四月 1日, 2020</p><p class="relate-post-content">\left和\rightTEX 有一个内置的机制, 能确定要封装住给定公式所需要的这对分界符的高度; 因此, 你可以使用这 种方法, 而不用自己在\big，\bigg或其它中筛选。所要做的只是：1\left&lt;delim1&gt...</p></div><div class="relate-post-cover"><a href="/编程语言/Tex/TeX公式Tips.html" title="TEX公式知识点拾遗"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="TEX公式知识点拾遗"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/编程语言/Node/nodejs-promise.html" title="nodejs中的Promise对象">nodejs中的Promise对象</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 十二月 9日, 2019</p><p class="relate-post-content">Promise是一种有三个状态的对象（“执行中pending”、“完成resolve”、“失败reject”），构造Promise对象时的构造函数参数是一个有两个参数的函数，这个函数的两个参数分别对应着Promise对象到达两个终点状...</p></div><div class="relate-post-cover"><a href="/编程语言/Node/nodejs-promise.html" title="nodejs中的Promise对象"><img class="lazy" src="/img/placeholder.jpg" data-src="/编程语言/Node/i/nodejs_4.png" alt="nodejs中的Promise对象"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/编程语言/Node/nodejs-feature.html" title="nodejs重要特性">nodejs重要特性</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 十二月 6日, 2019</p><p class="relate-post-content">回调函数如果看见某个函数定义长下面这样👇那它就应该是个带回调的函数。这类的函数一般为js内置，在调用的时候都是作为一个新线程运行的。1function some_function(param1,param2,callback)&#...</p></div><div class="relate-post-cover"><a href="/编程语言/Node/nodejs-feature.html" title="nodejs重要特性"><img class="lazy" src="/img/placeholder.jpg" data-src="/编程语言/Node/i/nodejs_1.jpg" alt="nodejs重要特性"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/编程语言/Shell/Shell-tips.html" title="Shell拾遗">Shell拾遗</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 十二月 3日, 2019</p><p class="relate-post-content">getopts和getopt这两个都是用来解析脚本运行时的命令行参数的。 getopts只能处理短选项，无法处理长选项，暂不介绍 getopt可以同时处理短选项和长选项。getopt命令不是一个标准的unix命令，但它在大多数Lin...</p></div><div class="relate-post-cover"><a href="/编程语言/Shell/Shell-tips.html" title="Shell拾遗"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="Shell拾遗"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/编程语言/Node/nodejs-tips.html" title="nodejs补充知识">nodejs补充知识</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 十一月 29日, 2019</p><p class="relate-post-content">在指定目录下运行npm 需求来源写了一个需要在本地保存文件的项目，想让这个项目能在任意位置保存文件，但是又不想单独为这一个功能单独搞配置文件，于是乎在代码里面用process.CWD()指定文件路径，使保存目录为程序实际运行的目录。...</p></div><div class="relate-post-cover"><a href="/编程语言/Node/nodejs-tips.html" title="nodejs补充知识"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="nodejs补充知识"></a></div></li></ul></div></div><div class="investment-content-list"><div class="layout-comment"><div>Please check the comment setting in config.yml of hexo-theme-Annie!</div></div></div><div class="investment-content-list"><div class="layout-share"><div class="social-share"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"><script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></div></div></div></div></div></div><script src="/plugin/clipboard/clipboard.js"></script><script>function codePreprocessing(){$("#article-content .highlight").each(function(){$(this).wrap('<div id="post-code"></div>')}),$("#article-content #post-code").each(function(){$(this).prepend('<nav class="copy-nav"><span><i class="code-language"></i></span></nav>')}),$("#article-content .copy-nav").each(function(){var t=$(this).next().attr("class"),e=9<t.length&&null!=t?t.substr(10):"none";$(this).find(".code-language").text(e),$(this).append('<span class="copy-btn"><i class="fa fa-copy" aria-hidden="true"></i></span>')})}function codeCopy(){$("#article-content #post-code").each(function(t){var e="codeCopy-"+t,n=$(this).find(".code"),o=$(this).find(".copy-btn");n.attr("id",e),o.attr("data-clipboard-target-id",e)});var t=new ClipboardJS(".copy-btn",{target:function(t){return document.getElementById(t.getAttribute("data-clipboard-target-id"))}});t.on("success",function(t){var e;t.clearSelection(),console.info("Action:",t.action),console.info("Trigger:",t.trigger),(e=t.trigger).setAttribute("aria-label","Copied!"),e.setAttribute("class","copy-btn copy-status"),setTimeout(function(){e.setAttribute("class","copy-btn")},2e3)}),t.on("error",function(t){console.error("Action:",t.action),console.error("Trigger:",t.trigger)})}$(".layout-post").length&&(codePreprocessing(),codeCopy())</script><link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css"><script src="/plugin/fancybox/jquery.fancybox.js"></script><script type="text/javascript">var titleID=$(".article-title a"),imageID=$(".article-content img"),videoID=$(".article-content video"),postTitle=titleID.text()?titleID.text():"No post title!";imageID.each(function(){var t=$(this).attr("src"),a=$(this).attr("alt")?$(this).attr("alt"):"No image description!";$(this).wrap('<a data-fancybox="gallery" data-caption=" 《 '+postTitle+" 》 "+a+' "  href=" '+t+' "> </a>')}),videoID.each(function(){var t=$(this).attr("src");$(this).wrap('<a data-fancybox href=" '+t+' "> </a>')}),$("#layout-post").length&&$('[data-fancybox="gallery"]').fancybox({loop:!0,buttons:["zoom","share","slideShow","fullScreen","thumbs","close"],protect:!1})</script></main><footer><div class="social"><ul><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-github"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-pinterest"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-instagram"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-twitter"></i></a></li><li><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li></ul></div><div class="copyright"><p>&copy;2017 - 2020, content by Howard Yin. All Rights Reserved.<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次</span></p><p><a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay. <a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> <a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a></p></div></footer><script src="/plugin/motto/motto.js"></script><script type="text/javascript">$(".motto").html(getMingYanContent())</script><div id="totop"><a href="javascript:;" name="TOTOP" class="fa fa-arrow-up"></a></div><script src="/plugin/vibrant/vibrant.js"></script><script src="/plugin/chinese/chinese.js"></script><script src="/plugin/imgLazyLoader/yall.min.js"></script><script src="/plugin/imgResize/jquery.resizeimagetoparent.min.js"></script><script src="/plugin/nicescroll/jquery.nicescroll.js"></script><script src="/js/resizediv.js"></script><script src="/js/main.js"></script><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></body></html>