<!DOCTYPE html><html class="html-loading"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>docker-compose的使用方法 | Howard-Blogs</title><meta name="author" content="Howard Yin"><meta name="keywords" content><meta name="description" content><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/Annie.css"><script src="/js/jquery.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script src="/js/leancloud.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css"></head><body><div id="preloader"><div class="pre-container"><div class="spinner"><div class="double-bounce1"></div><div class="double-bounce2"></div></div></div></div><header class="fixbackground" data-img-mode="normal" data-normal-src="/img/1.jpg" data-random-max="110" data-random-src="https://sariay.github.io/Random-img/"><div class="mask"><div class="h-header"><div id="logo"><a href="/"><img src="/img/logo.png" alt="Logo"></a></div><div id="navigation-show"><ul><li class="menu-home"><a href="/" class="menu-item-home">主页</a></li><li class="menu-archive"><a href="/archives" class="menu-item-archive">归档</a></li><li class="menu-categories"><a href="/categories" class="menu-item-categories">分类</a></li><li class="menu-tags"><a href="/tags" class="menu-item-tags">标签</a></li><li class="menu-about"><a href="/about" class="menu-item-about">关于</a></li><li class="menu-gallery"><a href="/gallery" class="menu-item-gallery">相册</a></li></ul></div></div><div class="h-body"><p class="motto"></p></div><div class="h-footer"><a href="javascript:;" id="read-more"><i class="fa fa-angle-double-down" aria-hidden="true"></i></a><style type="text/css">.header-date{font-size:1.6rem;color:#fff;position:absolute;bottom:5px;right:1rem;writing-mode:tb-rl}.header-date a{border-bottom:none}@media only screen and (max-width:768){.header-date{font-size:1rem}}</style><div class="header-date"><a href="https://time.is/Beijing" id="time_is_link" rel="nofollow"></a> <span id="Beijing_z43d"></span></div><script src="//widget.time.is/zh.js"></script><script>time_is_widget.init({Beijing_z43d:{template:"DATE",date_format:"year年 monthnum月 dnum日"}})</script></div></div></header><div id="navigation-hide"><div id="progress-bar"></div><div id="progress-percentage"><h1>0.0%</h1></div><div class="toc-switch"><span class="switch-button">目录</span></div><p>当前文章&nbsp;:&nbsp;《docker-compose的使用方法》</p><a class="nav-trigger"><span></span></a></div><nav class="nav-container" id="cd-nav"><div class="nav-header"><h3>Navigation</h3><a href="javascript:;" class="nav-close"></a></div><div class="nav-body"><ul><li class="menu-home"><a href="/" class="menu-item-home">主页</a></li><li class="menu-archive"><a href="/archives" class="menu-item-archive">归档</a></li><li class="menu-categories"><a href="/categories" class="menu-item-categories">分类</a></li><li class="menu-tags"><a href="/tags" class="menu-item-tags">标签</a></li><li class="menu-about"><a href="/about" class="menu-item-about">关于</a></li><li class="menu-gallery"><a href="/gallery" class="menu-item-gallery">相册</a></li></ul></div><div class="nav-footer"><ul><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-github"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-pinterest"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-instagram"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-twitter"></i></a></li><li><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li></ul></div></nav><main><div class="layout-toc"><div id="layout-toc"><div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div></div></div><script src="/plugin/toc/katelog.min.js"></script><div class="layout-post"><div id="layout-post"><div class="article-title"><i class="fa fa-paper-plane-o" aria-hidden="true"></i> <a href="/Docker/docker-compose.html" itemprop="url">docker-compose的使用方法</a></div><div class="article-meta"><span><i class="fa fa-calendar"></i> 发布于 <a href="/Docker/docker-compose.html" itemprop="url"><time datetime="2019-10-07T13:37:55.000Z" itemprop="datePublished">2019-10-07 </time></a>&nbsp; 更新于 <a href="/Docker/docker-compose.html" itemprop="url"><time datetime="2019-10-07T13:37:55.000Z" itemprop="dateUpdated">2020-06-24</time></a> </span><span><i class="fa fa-tags"></i> <a href="/tags/Docker/">Docker </a><a href="/tags/docker-compose/">docker-compose</a></span></div><div class="article-content" id="article-content"><p><a href="https://www.jianshu.com/p/658911a8cff3" target="_blank" rel="noopener">先来一个讲的比较好的博文</a></p><h2 id="什么玩意"><a class="markdownIt-Anchor" href="#什么玩意"></a> 什么玩意</h2><p>前面我们使用 Docker 的时候，定义Dockerfile文件，然后使用docker build、docker run等命令操作容器。然而微服务架构的应用系统一般包含若干个微服务，比如可能要有LAMP+redis+node+python+go+…每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，那么效率之低，维护量之大可想而知。所以就有docker-compose这种比docker image更上一层的工具。</p><p>docker-compose基本就是一个操作docker image的脚本，告诉计算机要怎么用docker image构建一个微服务系统。</p><h2 id="安装docker-compose"><a class="markdownIt-Anchor" href="#安装docker-compose"></a> 安装docker-compose</h2><p>windows上面装了docker-desktop就有docker-compose了。Linux上面的docker-compose安装自己找教程。</p><pre><code>docker-compose -v
</code></pre><p>确认一下👆</p><h2 id="概念工程-服务-容器"><a class="markdownIt-Anchor" href="#概念工程-服务-容器"></a> 概念：工程、服务、容器</h2><p>Docker Compose 将所管理的容器分为三层，分别是工程（project）、服务（service）、容器（container）<br>Docker Compose 运行目录下的所有文件（docker-compose.yml）组成一个工程,一个工程包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖，一个服务可包括多个容器实例</p><h2 id="docker-compose语法"><a class="markdownIt-Anchor" href="#docker-compose语法"></a> docker-compose语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;5000:5000&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - .:/code</span><br><span class="line">    - logvolume01:/var/log</span><br><span class="line">    links:</span><br><span class="line">    - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">volumes:</span><br><span class="line">  logvolume01: &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="版本号"><a class="markdownIt-Anchor" href="#版本号"></a> 版本号</h3><p>第一行那个是docker-compose文件的版本号，不同的版本号受支持的docker-compose不同。</p><h3 id="services"><a class="markdownIt-Anchor" href="#services"></a> <code>services:</code></h3><p>定义了一个工程，一个工程(services)里面会包含多个服务(service)，上面这个工程包含了两个服务web和redis</p><h4 id="build和image"><a class="markdownIt-Anchor" href="#build和image"></a> <code>build</code>和<code>image</code></h4><p>在一个容器的定义中，build表示这个容器是通过一个Dockerfile构建出来的，而image表示这个容器直接使用了一个云端的image。</p><p>上面那个容器<code>web:</code>中的<code>build:.</code>表示在用目录的Dockerfile构建容器。<code>redis:</code>中的<code>image: redis</code>表示直接用redis镜像构建容器。</p><h4 id="ports和volumes"><a class="markdownIt-Anchor" href="#ports和volumes"></a> <code>ports</code>和<code>volumes</code></h4><p>端口映射，等同于在docker run启动容器时的<code>-p</code>和<code>-v</code>参数。</p><h4 id="links"><a class="markdownIt-Anchor" href="#links"></a> <code>links</code></h4><p>docker-compose启动后会在主机中建立一个DNS服务器，如果是按照上面的docker-compose文件启动，主机除了可以通过<code>http://127.0.0.1:5000</code>（<code>web:ports</code>指定的主机端口映射）访问<code>web</code>容器之外，还可以通过<code>http://web:5000</code>和<code>redis:6379</code>（就是<code>[网址]:[端口]</code>）访问<code>web</code>容器和<code>redis</code>容器。</p><blockquote><p>Containers for the linked service are reachable at a hostname identical to the alias, or the service name if no alias was specified.</p></blockquote><p>当使用如上所示的<code>web:links:-redis</code>之后，在<code>web</code>容器里面也可以用<code>redis:6379</code>（6379是redis默认端口和容器设置无关）访问<code>redis</code>容器了。<code>links</code>还可以定义一个别名，如<code>links:-&quot;redis:rds&quot;</code>（注意引号），这时就是用<code>rds:6379</code>访问<code>redis</code>容器。</p><p>常见但已经不建议使用，打上<code>links</code>之后docker-compose会按顺序启动容器，上面的例子中<code>web:links:-redis</code>之后web容器会在redis容器启动完才启动；但是如果后续开发我又想让<code>redis</code>里面能访问<code>web</code>呢？那当然是再在<code>redis</code>里面写个<code>redis:links:-web</code>了？这么写了docker-compose直接给我报了个“循环依赖”错误🙂呵呵。</p><p>所以links只是一个简单的容器互联方法，比较复杂的容器互联正确姿势见下一节。</p><blockquote><p>Warning: The <code>--link</code> flag is a legacy feature of Docker. It may eventually be removed. Unless you absolutely need to continue using it, we recommend that you use user-defined networks to facilitate communication between two containers instead of using <code>--link</code>. One feature that user-defined networks do not support that you can do with <code>--link</code> is sharing environmental variables between containers. However, you can use other mechanisms such as volumes to share environment variables between containers in a more controlled way.</p></blockquote><h2 id="容器互联"><a class="markdownIt-Anchor" href="#容器互联"></a> 容器互联</h2><h3 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h3><blockquote><p>One of the reasons Docker containers and services are so powerful is that you can connect them together, or connect them to non-Docker workloads. Docker containers and services do not even need to be aware that they are deployed on Docker, or whether their peers are also Docker workloads or not. Whether your Docker hosts run Linux, Windows, or a mix of the two, you can use Docker to manage them in a platform-agnostic way.</p></blockquote><p>容器互联就是将各个独立的Docker容器连接在一起，就好像它们里面的程序运行在一个系统中。容器互联的方式基本上是通过虚拟的网络连接和一些端口映射使容器内部能通过某个端口或IP访问到其他的容器。</p><h3 id="正确姿势"><a class="markdownIt-Anchor" href="#正确姿势"></a> 正确姿势</h3><p>定义一个<code>network</code>取名<code>net1</code>，然后把要互联的容器<code>networks</code>字段里面写上这个<code>net1</code>然后它们就能像互相links过一样互联了👇而且不会有“循环依赖”。不过这时候容器间没有依赖关系而会同时启动，对于确实有依赖关系的容器，就用<code>depends_on</code>属性👉<a href="https://docs.docker.com/compose/compose-file/#/dependson" target="_blank" rel="noopener">请看这个</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;5000:5000&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - .:/code</span><br><span class="line">    - logvolume01:/var/log</span><br><span class="line">    networks:</span><br><span class="line">    - &quot;net1&quot;</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    networks:</span><br><span class="line">    - &quot;net1&quot;</span><br><span class="line">volumes:</span><br><span class="line">  logvolume01: &#123;&#125;</span><br><span class="line">networks:</span><br><span class="line">  net1:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><p>👆这个完事了之后<code>web</code>容器里面可以访问到<code>redis:6379</code>，<code>redis</code>容器里面也可以访问到<code>web:5000</code>了。关于<code>networks</code>里面的<code>driver</code>字段请看下文👇。</p><h3 id="bridge模式"><a class="markdownIt-Anchor" href="#bridge模式"></a> Bridge模式</h3><p>Bridge是docker网络连接的默认模式，效果和上文中的那个<code>links</code>效果一样，设置完之后就是通过<code>[名称]:[端口]</code>访问容器。</p><p>👆这个比较常用</p><p><a href="https://docs.docker.com/network/network-tutorial-standalone/" target="_blank" rel="noopener">具体怎么设置，看这个从命令行开始的范例</a></p><h3 id="host模式"><a class="markdownIt-Anchor" href="#host模式"></a> Host模式</h3><p>Host模式是一种特殊的Bridge。正常的Birdge都是容器间互联，Host就是容器和主机间互联。效果同<code>docker run</code>中的<code>-p</code>参数指定端口映射一样。</p><p><a href="https://docs.docker.com/network/network-tutorial-host/" target="_blank" rel="noopener">这个so easy，点我看范例</a></p><p><a href="https://docs.docker.com/network/" target="_blank" rel="noopener">翻译一下这个，应该就能用起来了</a></p><h3 id="overlay和macvlan模式"><a class="markdownIt-Anchor" href="#overlay和macvlan模式"></a> Overlay和Macvlan模式</h3><ul><li>Overlay模式用于有多个物理主机的集群(Swarm)</li><li>Macvlan模式是基于MAC地址和vlan设置的网络</li></ul><p>👆暂时用不到，告辞</p><h2 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h2><p>一个简单的例子👇在<code>web</code>容器中把DEBUG环境变量设为1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    environment:</span><br><span class="line">      DEBUG: 1</span><br></pre></td></tr></table></figure></div><div id="current-post-cover" data-scr="/img/cart_cover.jpg"></div><div class="investment-container"><div class="investment-header"><div class="investment-title-1"><div class="on">相关文章</div><div>评论</div><div>分享</div></div><div class="investment-title-2"><span><a href="javascript: window.scrollTo(0, 0);">返回顶部</a> <a href="/翻译/Pattern Decompose by business capability.html" title="模式：根据业务能力拆分" rel="prev">&laquo;上一篇 </a><a href="/数据库/各种数据库概述.html" title="各种数据库概述" rel="next">下一篇&raquo;</a></span></div></div><div class="investment-content"><div class="investment-content-list"><div class="relate-post"><ul><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/cgroups.html" title="Linux Cgroups (Control Groups)">Linux Cgroups (Control Groups)</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 19日, 2020</p><p class="relate-post-content">Docker背后的内核知识——cgroups资源限制通俗的来说，cgroups可以限制、记录、隔离进程组所使用的物理资源（包括：CPU、memory、IO等），为容器实现虚拟化提供了基本保证，是构建Docker等一系列虚拟化管理工具的...</p></div><div class="relate-post-cover"><a href="/Docker/cgroups.html" title="Linux Cgroups (Control Groups)"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="Linux Cgroups (Control Groups)"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/sane_behavior.html" title="【纯转载】下一代的CGroup">【纯转载】下一代的CGroup</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 19日, 2020</p><p class="relate-post-content">原文上面，我们可以看到，CGroup的一些常用方法和相关的术语。一般来说，这样的设计在一般情况下还是没什么问题的，除了操作上的用户体验不是很好，但基本满足我们的一般需求了。不过，对此，有个叫Tejun Heo的同学非常不爽，他在Lin...</p></div><div class="relate-post-cover"><a href="/Docker/sane_behavior.html" title="【纯转载】下一代的CGroup"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="【纯转载】下一代的CGroup"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/namespace.html" title="namespace">namespace</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">引入：Linux上的资源隔离指令chrootchroot，即 change root directory，更改 root 目录。在 linux 系统中，系统默认的目录结构都是以/，即是以根 (root) 开始的。而在使用 chroo...</p></div><div class="relate-post-cover"><a href="/Docker/namespace.html" title="namespace"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="namespace"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/AUFS.html" title="AUFS技术">AUFS技术</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">教程参考AUFS是一种联合文件系统 (Union File System, UnionFS, UFS)。AUFS又叫Another UnionFS，后来叫Alternative UnionFS，后来可能觉得不够霸气，叫成Advance...</p></div><div class="relate-post-cover"><a href="/Docker/AUFS.html" title="AUFS技术"><img class="lazy" src="/img/placeholder.jpg" data-src="/Docker/i/AUFS和Docker.png" alt="AUFS技术"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/namespaces/Network.html" title="Network namespace">Network namespace</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">Linux 虚拟网络设备 TUN/TAPTUN 设备是一种虚拟网络设备，通过此设备，程序可以方便得模拟网络行为。对于物理设备，其协议栈从物理网卡中读写数据：而TUN 设备的协议栈从文件中读写数据：所有对这个文件的写操作会通过 TUN...</p></div><div class="relate-post-cover"><a href="/Docker/namespaces/Network.html" title="Network namespace"><img class="lazy" src="/img/placeholder.jpg" data-src="/Docker/namespaces/../i/Linux虚拟网络设备.png" alt="Network namespace"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/namespaces/PIDandIPC.html" title="PID namespace">PID namespace</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">内核为所有的PID namespace维护了一个树状结构，最顶层的是系统初始时创建的，我们称之为root namespace。他创建的新PID namespace就称之为child namespace（树的子节点），而原先的PID n...</p></div><div class="relate-post-cover"><a href="/Docker/namespaces/PIDandIPC.html" title="PID namespace"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="PID namespace"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/namespaces/UTSandUser.html" title="UTS(UNIX Time-sharing System) namespace">UTS(UNIX Time-sharing System) namespace</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">Uts_namespace分析 UTS是什么当前一个系统的uts是linux主机所用的操作系统的版本、硬件名称等基本信息。uts信息在操作系统内核中定义为一个结构体,其值可以通过一些set*函数设置：12345678struct ne...</p></div><div class="relate-post-cover"><a href="/Docker/namespaces/UTSandUser.html" title="UTS(UNIX Time-sharing System) namespace"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="UTS(UNIX Time-sharing System) namespace"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/namespaces/Mount.html" title="Mount namespace">Mount namespace</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">它是历史上第一个Linux namespace，所以它的标识位比较特殊，就是CLONE_NEWNS。Mount namespace通过隔离文件系统挂载点对隔离文件系统提供支持，当我们使用 clone 函数或 unshare 函数并传入...</p></div><div class="relate-post-cover"><a href="/Docker/namespaces/Mount.html" title="Mount namespace"><img class="lazy" src="/img/placeholder.jpg" data-src="/Docker/namespaces/../i/mountnamespace.png" alt="Mount namespace"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/原理概述.html" title="Docker原理概述">Docker原理概述</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">Any problem in computer science can be solved by another layer of indirection.计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。基础教程VMWa...</p></div><div class="relate-post-cover"><a href="/Docker/原理概述.html" title="Docker原理概述"><img class="lazy" src="/img/placeholder.jpg" data-src="/Docker/i/虚拟机架构.png" alt="Docker原理概述"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/Docker-proxy.html" title="Docker 代理总结">Docker 代理总结</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 十二月 18日, 2019</p><p class="relate-post-content">为docker pull设置代理给docker pull意味着通过代理下载镜像。 在windows上docker desktop上的proxies设置就是设置的docker pull代理。默认情况下是10.0.75.1而不是127....</p></div><div class="relate-post-cover"><a href="/Docker/Docker-proxy.html" title="Docker 代理总结"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="Docker 代理总结"></a></div></li></ul></div></div><div class="investment-content-list"><div class="layout-comment"><div>Please check the comment setting in config.yml of hexo-theme-Annie!</div></div></div><div class="investment-content-list"><div class="layout-share"><div class="social-share"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"><script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></div></div></div></div></div></div><script src="/plugin/clipboard/clipboard.js"></script><script>function codePreprocessing(){$("#article-content .highlight").each(function(){$(this).wrap('<div id="post-code"></div>')}),$("#article-content #post-code").each(function(){$(this).prepend('<nav class="copy-nav"><span><i class="code-language"></i></span></nav>')}),$("#article-content .copy-nav").each(function(){var t=$(this).next().attr("class"),e=9<t.length&&null!=t?t.substr(10):"none";$(this).find(".code-language").text(e),$(this).append('<span class="copy-btn"><i class="fa fa-copy" aria-hidden="true"></i></span>')})}function codeCopy(){$("#article-content #post-code").each(function(t){var e="codeCopy-"+t,n=$(this).find(".code"),o=$(this).find(".copy-btn");n.attr("id",e),o.attr("data-clipboard-target-id",e)});var t=new ClipboardJS(".copy-btn",{target:function(t){return document.getElementById(t.getAttribute("data-clipboard-target-id"))}});t.on("success",function(t){var e;t.clearSelection(),console.info("Action:",t.action),console.info("Trigger:",t.trigger),(e=t.trigger).setAttribute("aria-label","Copied!"),e.setAttribute("class","copy-btn copy-status"),setTimeout(function(){e.setAttribute("class","copy-btn")},2e3)}),t.on("error",function(t){console.error("Action:",t.action),console.error("Trigger:",t.trigger)})}$(".layout-post").length&&(codePreprocessing(),codeCopy())</script><link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css"><script src="/plugin/fancybox/jquery.fancybox.js"></script><script type="text/javascript">var titleID=$(".article-title a"),imageID=$(".article-content img"),videoID=$(".article-content video"),postTitle=titleID.text()?titleID.text():"No post title!";imageID.each(function(){var t=$(this).attr("src"),a=$(this).attr("alt")?$(this).attr("alt"):"No image description!";$(this).wrap('<a data-fancybox="gallery" data-caption=" 《 '+postTitle+" 》 "+a+' "  href=" '+t+' "> </a>')}),videoID.each(function(){var t=$(this).attr("src");$(this).wrap('<a data-fancybox href=" '+t+' "> </a>')}),$("#layout-post").length&&$('[data-fancybox="gallery"]').fancybox({loop:!0,buttons:["zoom","share","slideShow","fullScreen","thumbs","close"],protect:!1})</script></main><footer><div class="social"><ul><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-github"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-pinterest"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-instagram"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-twitter"></i></a></li><li><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li></ul></div><div class="copyright"><p>&copy;2017 - 2020, content by Howard Yin. All Rights Reserved.<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次</span></p><p><a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay. <a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> <a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a></p></div></footer><script src="/plugin/motto/motto.js"></script><script type="text/javascript">$(".motto").html(getMingYanContent())</script><div id="totop"><a href="javascript:;" name="TOTOP" class="fa fa-arrow-up"></a></div><script src="/plugin/vibrant/vibrant.js"></script><script src="/plugin/chinese/chinese.js"></script><script src="/plugin/imgLazyLoader/yall.min.js"></script><script src="/plugin/imgResize/jquery.resizeimagetoparent.min.js"></script><script src="/plugin/nicescroll/jquery.nicescroll.js"></script><script src="/js/resizediv.js"></script><script src="/js/main.js"></script><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></body></html>