<!DOCTYPE html><html class="html-loading"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Linux Cgroups (Control Groups) | Howard-Blogs</title><meta name="author" content="Howard Yin"><meta name="keywords" content><meta name="description" content><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/Annie.css"><script src="/js/jquery.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script src="/js/leancloud.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css"></head><body><div id="preloader"><div class="pre-container"><div class="spinner"><div class="double-bounce1"></div><div class="double-bounce2"></div></div></div></div><header class="fixbackground" data-img-mode="normal" data-normal-src="/img/1.jpg" data-random-max="110" data-random-src="https://sariay.github.io/Random-img/"><div class="mask"><div class="h-header"><div id="logo"><a href="/"><img src="/img/logo.png" alt="Logo"></a></div><div id="navigation-show"><ul><li class="menu-home"><a href="/" class="menu-item-home">主页</a></li><li class="menu-archive"><a href="/archives" class="menu-item-archive">归档</a></li><li class="menu-categories"><a href="/categories" class="menu-item-categories">分类</a></li><li class="menu-tags"><a href="/tags" class="menu-item-tags">标签</a></li><li class="menu-about"><a href="/about" class="menu-item-about">关于</a></li><li class="menu-gallery"><a href="/gallery" class="menu-item-gallery">相册</a></li></ul></div></div><div class="h-body"><p class="motto"></p></div><div class="h-footer"><a href="javascript:;" id="read-more"><i class="fa fa-angle-double-down" aria-hidden="true"></i></a><style type="text/css">.header-date{font-size:1.6rem;color:#fff;position:absolute;bottom:5px;right:1rem;writing-mode:tb-rl}.header-date a{border-bottom:none}@media only screen and (max-width:768){.header-date{font-size:1rem}}</style><div class="header-date"><a href="https://time.is/Beijing" id="time_is_link" rel="nofollow"></a> <span id="Beijing_z43d"></span></div><script src="//widget.time.is/zh.js"></script><script>time_is_widget.init({Beijing_z43d:{template:"DATE",date_format:"year年 monthnum月 dnum日"}})</script></div></div></header><div id="navigation-hide"><div id="progress-bar"></div><div id="progress-percentage"><h1>0.0%</h1></div><div class="toc-switch"><span class="switch-button">目录</span></div><p>当前文章&nbsp;:&nbsp;《Linux Cgroups (Control Groups)》</p><a class="nav-trigger"><span></span></a></div><nav class="nav-container" id="cd-nav"><div class="nav-header"><h3>Navigation</h3><a href="javascript:;" class="nav-close"></a></div><div class="nav-body"><ul><li class="menu-home"><a href="/" class="menu-item-home">主页</a></li><li class="menu-archive"><a href="/archives" class="menu-item-archive">归档</a></li><li class="menu-categories"><a href="/categories" class="menu-item-categories">分类</a></li><li class="menu-tags"><a href="/tags" class="menu-item-tags">标签</a></li><li class="menu-about"><a href="/about" class="menu-item-about">关于</a></li><li class="menu-gallery"><a href="/gallery" class="menu-item-gallery">相册</a></li></ul></div><div class="nav-footer"><ul><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-github"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-pinterest"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-instagram"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-twitter"></i></a></li><li><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li></ul></div></nav><main><div class="layout-toc"><div id="layout-toc"><div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div></div></div><script src="/plugin/toc/katelog.min.js"></script><div class="layout-post"><div id="layout-post"><div class="article-title"><i class="fa fa-paper-plane-o" aria-hidden="true"></i> <a href="/Docker/cgroups.html" itemprop="url">Linux Cgroups (Control Groups)</a></div><div class="article-meta"><span><i class="fa fa-calendar"></i> 发布于 <a href="/Docker/cgroups.html" itemprop="url"><time datetime="2020-06-19T13:46:57.000Z" itemprop="datePublished">2020-06-19 </time></a>&nbsp; 更新于 <a href="/Docker/cgroups.html" itemprop="url"><time datetime="2020-06-19T13:46:57.000Z" itemprop="dateUpdated">2020-06-24</time></a> </span><span><i class="fa fa-tags"></i> <a href="/tags/Docker/">Docker </a><a href="/tags/Linux/">Linux</a></span></div><div class="article-content" id="article-content"><p><a href="http://www.sel.zju.edu.cn/?p=573" target="_blank" rel="noopener">Docker背后的内核知识——cgroups资源限制</a></p><p>通俗的来说，cgroups可以<strong>限制、记录、隔离进程组所使用的物理资源</strong>（包括：CPU、memory、IO等），为容器实现虚拟化提供了基本保证，是构建Docker等一系列虚拟化管理工具的基石。实现cgroups的主要目的是为不同用户层面的资源管理提供一个统一化的接口。从单个进程的资源控制到操作系统层面的虚拟化。Cgroups提供了以下四大功能：</p><ul><li>资源限制（Resource Limitation）：cgroups可以对进程组使用的资源总额进行限制。如设定应用运行时使用内存的上限，一旦超过这个配额就发出OOM（Out of Memory）。</li><li>优先级分配（Prioritization）：通过分配的CPU时间片数量及硬盘IO带宽大小，实际上就相当于控制了进程运行的优先级。</li><li>资源统计（Accounting）： cgroups可以统计系统的资源使用量，如CPU使用时长、内存用量等等，这个功能非常适用于计费。</li><li>进程控制（Control）：cgroups可以对进程组执行挂起、恢复等操作。</li></ul><h2 id="相关定义"><a class="markdownIt-Anchor" href="#相关定义"></a> 相关定义</h2><ol><li>task：一个进程</li><li>cgroup：按某种资源控制标准划分而成的task组，包含一个或多个subsystem</li><li>subsystem：资源调度控制器，Linux支持12种subsystem，比如CPU subsystem可以控制CPU时间分配，内存 subsystem可以限制cgroup内存使用量</li><li>hierarchy：一系列cgroup以一个树状结构排列而成，每个hierarchy通过绑定对应的subsystem进行资源调度</li></ol><h2 id="基本规则"><a class="markdownIt-Anchor" href="#基本规则"></a> 基本规则</h2><h3 id="task-cgroup-subsystem-hierarchy关系"><a class="markdownIt-Anchor" href="#task-cgroup-subsystem-hierarchy关系"></a> task、cgroup、subsystem、hierarchy关系</h3><ol><li>同一个hierarchy可以附加零到多个subsystem</li><li>一个subsystem只可以附加到一个hierarchy</li><li>每一个hierarchy里面，都包含Linux系统中的所有task</li><li>一个task可以在多个hierarchy里，但不能在同一个hierarchy的多个cgroup中</li></ol><pre class="mermaid">graph LR
task(task)--n---包含{包含}--1---cgroup(cgroup)--n---属于{属于}--1---hierarchy(hierarchy)--1---绑定{绑定}--n---subsystem(subsystem)</pre><p><code>/proc/cgroups</code>文件中可以看到当前的subsystem情况，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#subsys_name    hierarchy       num_cgroups     enabled</span></span><br><span class="line">cpuset          11              1               1</span><br><span class="line">cpu             3               64              1</span><br><span class="line">cpuacct         3               64              1</span><br><span class="line">blkio           8               64              1</span><br><span class="line">memory          9               104             1</span><br><span class="line">devices         5               64              1</span><br><span class="line">freezer         10              4               1</span><br><span class="line">net_cls         6               1               1</span><br><span class="line">perf_event      7               1               1</span><br><span class="line">net_prio        6               1               1</span><br><span class="line">hugetlb         4               1               1</span><br><span class="line">pids            2               68              1</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>subsys_name</code>表示subsystem名称</li><li><code>hierarchy</code>表示该subsystem绑定的hierarchy编号</li><li><code>num_cgroups</code>表示该subsystem绑定的hierarchy中的task数量</li><li><code>enabled</code>表示该subsystem是否启动</li></ul><h4 id="subsystem分类"><a class="markdownIt-Anchor" href="#subsystem分类"></a> subsystem分类</h4><ul><li>cpu (since Linux 2.6.24; CONFIG_CGROUP_SCHED)<ul><li>用来限制cgroup的CPU使用率。</li></ul></li><li>cpuacct (since Linux 2.6.24; CONFIG_CGROUP_CPUACCT)<ul><li>统计cgroup的CPU的使用率。</li></ul></li><li>cpuset (since Linux 2.6.24; CONFIG_CPUSETS)<ul><li>绑定cgroup到指定CPUs和NUMA节点。</li></ul></li><li>memory (since Linux 2.6.25; CONFIG_MEMCG)<ul><li>统计和限制cgroup的内存的使用率，包括process memory, kernel memory, 和swap。</li></ul></li><li>devices (since Linux 2.6.26; CONFIG_CGROUP_DEVICE)<ul><li>限制cgroup创建(mknod)和访问设备的权限。</li></ul></li><li>freezer (since Linux 2.6.28; CONFIG_CGROUP_FREEZER)<ul><li>suspend和restore一个cgroup中的所有进程。</li></ul></li><li>net_cls (since Linux 2.6.29; CONFIG_CGROUP_NET_CLASSID)<ul><li>将一个cgroup中进程创建的所有网络包加上一个classid标记，用于tc和iptables。 只对发出去的网络包生效，对收到的网络包不起作用。</li></ul></li><li>blkio (since Linux 2.6.33; CONFIG_BLK_CGROUP)<ul><li>限制cgroup访问块设备的IO速度。</li></ul></li><li>perf_event (since Linux 2.6.39; CONFIG_CGROUP_PERF)<ul><li>对cgroup进行性能监控<br>net_prio (since Linux 3.3; CONFIG_CGROUP_NET_PRIO)</li><li>针对每个网络接口设置cgroup的访问优先级。</li></ul></li><li>hugetlb (since Linux 3.5; CONFIG_CGROUP_HUGETLB)<ul><li>限制cgroup的huge pages的使用量。</li></ul></li><li>pids (since Linux 4.3; CONFIG_CGROUP_PIDS)<ul><li>限制一个cgroup及其子孙cgroup中的总进程数。</li></ul></li></ul><h3 id="cgroups运行规则"><a class="markdownIt-Anchor" href="#cgroups运行规则"></a> cgroups运行规则</h3><ol><li>新建一个hierarchy时，系统上当前运行的所有进程构成该hierarchy中的第一个cgroup，称为root cgroup</li><li>把一个cgroup中的task添加到同一个hierarchy中的另一个cgroup中，则会自动从之前cgroup中移除</li><li>创建子进程时，子进程与父进程在同一个cgroup，但是子进程随后可以自由移动到其他cgroup</li></ol><h2 id="cgroup的使用"><a class="markdownIt-Anchor" href="#cgroup的使用"></a> cgroup的使用</h2><h3 id="创建hierarchy及root-cgroup"><a class="markdownIt-Anchor" href="#创建hierarchy及root-cgroup"></a> 创建hierarchy及root cgroup</h3><p>cgroup相关的所有操作都是基于内核中的cgroup virtual filesystem，使用cgroup很简单，使用<code>mount -t cgroup -o cpu,cpuacct</code>挂载一个文件系统就可以了，需要哪个subsystem就挂载到哪个subsystem的目录下。挂载到任何目录都可以，一般情况下都是挂载到<code>/sys/fs/cgroup</code>目录下。例如：</p><p>创建一个绑定所有subsystem的hierarchy：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t cgroup [hierarchy目录] /sys/fs/cgroup</span><br></pre></td></tr></table></figure><p>创建一个绑定cpuset subsystem的hierarchy：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /sys/fs/cgroup/cpuset</span><br><span class="line">mount -t cgroup -o cpuset [hierarchy目录] /sys/fs/cgroup/cpuset</span><br></pre></td></tr></table></figure><p>创建一个绑定cpu和cpuacct subsystem的hierarchy：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /sys/fs/cgroup/cpu,cpuacct</span><br><span class="line">mount -t cgroup -o cpu,cpuacct [hierarchy目录] /sys/fs/cgroup/cpu,cpuacct</span><br></pre></td></tr></table></figure><p>创建一个不绑定任何subsystem的hierarchy，下面就是linux中systemd所用到的方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /sys/fs/cgroup/systemd</span><br><span class="line">mount -t cgroup -o none,name=systemd xxx /sys/fs/cgroup/systemd</span><br></pre></td></tr></table></figure><p>如果要绑定一个已经被绑定到其他hierarchy的subsystem，则会报错。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -t cgroup -o devices,pids new-devices-pids ./devices,pids</span><br><span class="line">mount: new-devices-pids is already mounted or /home/dev/cgroup/devices,pids busy</span><br></pre></td></tr></table></figure><h3 id="创建删除子cgroup"><a class="markdownIt-Anchor" href="#创建删除子cgroup"></a> 创建/删除子cgroup</h3><p>创建子cgroup即在cgroup目录下创建一个文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [cgroup文件夹]</span><br></pre></td></tr></table></figure><p>删除子cgroup即删除这个文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [cgroup文件夹]</span><br></pre></td></tr></table></figure><p>如果要删除的cgroup包含有子cgroup或进程，则会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir: failed to remove <span class="string">'[cgroup文件夹]/'</span>: Device or resource busy</span><br></pre></td></tr></table></figure><h3 id="cgroup目录下的文件"><a class="markdownIt-Anchor" href="#cgroup目录下的文件"></a> cgroup目录下的文件</h3><p>当挂载hierarchy或在创建子cgroup文件夹时，一些文件会自动生成。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /sys/fs/cgroup/cpu</span><br><span class="line">cgroup.clone_children  cgroup.procs  cgroup.sane_behavior  notify_on_release  release_agent tasks</span><br></pre></td></tr></table></figure><ul><li>cgroup.clone_children：当该文件的内容为1时，新创建的cgroup将会继承父cgroup的配置，即从父cgroup里面拷贝配置文件来初始化新cgroup<ul><li>只对cpuset（subsystem）有影响</li></ul></li><li>cgroup.procs：当前cgroup中的所有<strong>进程</strong>ID</li><li>tasks：当前cgroup中的所有<strong>线程</strong>ID</li><li>notify_on_release：该文件的内容为1时，<strong>当cgroup退出时（不再包含任何进程和子cgroup），将调用release_agent里面配置的命令</strong><ul><li>新cgroup被创建时将默认继承父cgroup的这项配置。</li></ul></li><li>release_agent：cgroup退出时将会执行的命令，系统调用该命令时会将相应cgroup的相对路径当作参数传进去<ul><li>这个文件只会存在于root cgroup文件夹下</li></ul></li><li>cgroup.sane_behavior：与下一代CGroup中的sane_behavior有关</li></ul><p>除上述文件之外，还可能会有：</p><ul><li>pids.current: 表示当前cgroup及其所有子孙cgroup中现有的总的进程数量</li><li>pids.max: 当前cgroup及其所有子孙cgroup中所允许创建的总的最大进程数量<ul><li>root cgroup下没有这个文件，原因显而易见，因为我们没有必要限制整个系统所能创建的进程数量</li></ul></li></ul><h4 id="注下一代的cgroup和sane-behavior介绍"><a class="markdownIt-Anchor" href="#注下一代的cgroup和sane-behavior介绍"></a> 注：<a href="./sane_behavior.md">下一代的CGroup和sane behavior介绍</a></h4><h3 id="添加进程"><a class="markdownIt-Anchor" href="#添加进程"></a> 添加进程</h3><p>执行添加进程操作只要在cgroup.procs写入PID即可，有cgroup.procs写入权限即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> [进程PID] &gt; cgroup.procs</span><br></pre></td></tr></table></figure><p>如果此进程已经在同hierarchy的另一个cgroup里面了，上述操作会自动从原来的cgroup中删除。</p><p>注：进程移动时，进程下的线程会随之一起移动，可以在<code>tasks</code>文件中看到</p><h2 id="cgroup进行资源限制"><a class="markdownIt-Anchor" href="#cgroup进行资源限制"></a> cgroup进行资源限制</h2><h3 id="限制内存"><a class="markdownIt-Anchor" href="#限制内存"></a> 限制内存</h3><p>挂载一个memory subsystem，除上文所述<code>cgroup.*</code>文件外，对应目录下会有一系列与内存限制相关的文件：</p><table><thead><tr><th>文件名</th><th>用途</th></tr></thead><tbody><tr><td>cgroup.event_control</td><td>用于eventfd的接口</td></tr><tr><td>memory.usage_in_bytes</td><td>显示当前已用的内存</td></tr><tr><td>memory.limit_in_bytes</td><td>设置/显示当前限制的内存额度</td></tr><tr><td>memory.failcnt</td><td>显示内存使用量达到限制值的次数</td></tr><tr><td>memory.max_usage_in_bytes</td><td>历史内存最大使用量</td></tr><tr><td>memory.soft_limit_in_bytes</td><td>设置/显示当前限制的内存软额度</td></tr><tr><td>memory.stat</td><td>显示当前cgroup的内存使用情况</td></tr><tr><td>memory.use_hierarchy</td><td>设置/显示是否将子cgroup的内存使用情况统计到当前cgroup里面</td></tr><tr><td>memory.force_empty</td><td>写入0时触发系统立即尽可能的回收当前cgroup中可以回收的内存</td></tr><tr><td>memory.pressure_level</td><td>设置内存压力的通知事件，配合cgroup.event_control一起使用</td></tr><tr><td>memory.swappiness</td><td>设置和显示当前的swappiness</td></tr><tr><td>memory.move_charge_at_immigrate</td><td>设置当进程移动到其他cgroup中时，它所占用的内存是否也随着移动过去</td></tr><tr><td>memory.oom_control</td><td>设置/显示oom controls相关的配置</td></tr><tr><td>memory.numa_stat</td><td>显示numa相关的内存</td></tr></tbody></table><ul><li>memory.usage_in_bytes<ul><li>读此文件获得当前使用的内存大小（正整数字符串），单位字节</li></ul></li><li>memory.limit_in_bytes<ul><li>读此文件获得当前的内存大小限制（正整数字符串），单位字节</li><li>写此文件设置内存大小限制（正整数字符串），单位字节</li><li>向此文件写入“-1”取消限制</li></ul></li><li>memory.soft_limit_in_bytes<ul><li>当系统内存充裕时，soft limit不起任何作用</li><li>当系统内存吃紧时，系统会尽量的将cgroup的内存限制在soft limit值之下（内核会尽量，但不100%保证）</li><li>正确用法：给次等重要的进程设置soft limit，当系统内存吃紧时，把机会让给其它重要的进程</li></ul></li><li>memory.failcnt<ul><li>读此文件获取物理内存使用量达到限制值的次数</li><li>当内存内容超过memory.limit_in_bytes限额时，memory.failcnt内容的值加一，超出内容放入swap分区</li><li>若物理内存已达memory.limit_in_bytes上限而swap分区容量不足，后续所有申请内存的进程操作视memory.oom_control而定</li></ul></li><li>memory.oom_control<ul><li>向此文件写入“0”，则物理内存已达memory.limit_in_bytes上限而swap分区容量不足时直接kill掉该进程</li><li>向此文件写入“1”，则物理内存已达memory.limit_in_bytes上限而swap分区容量不足时暂停该进程直到有空余的内存之后再继续运行</li><li>root cgroup的memory.oom_control写“1”无效，永远采取直接kill掉该进程的策略</li></ul></li><li>memory.use_hierarchy<ul><li>该文件内容为0时，表示不使用继承，即父子cgroup之间没有关系</li><li>当该文件内容为1时，子cgroup所占用的内存会统计到所有祖先cgroup中，当一个cgroup内存吃紧时，会触发系统回收它以及它所有子孙cgroup的内存</li></ul></li></ul><h3 id="限制cpu使用率"><a class="markdownIt-Anchor" href="#限制cpu使用率"></a> 限制CPU使用率</h3><p>挂载一个memory subsystem，除上文所述<code>cgroup.*</code>文件外，对应目录下会有一系列与CPU使用率限制相关的文件：</p><table><thead><tr><th>文件名</th><th>用途</th></tr></thead><tbody><tr><td>cpu.cfs_period_us</td><td>配置总时间周期长度</td></tr><tr><td>cpu.cfs_quota_us</td><td>当前cgroup所能使用的时间周期长度</td></tr><tr><td>cpu.shares</td><td>设置CPU的相对值</td></tr><tr><td>cpu.stat</td><td>CPU使用统计结果</td></tr></tbody></table><h4 id="cpu使用时间上限cpucfs_period_us和cpucfs_quota_us"><a class="markdownIt-Anchor" href="#cpu使用时间上限cpucfs_period_us和cpucfs_quota_us"></a> CPU使用时间上限：cpu.cfs_period_us和cpu.cfs_quota_us</h4><p>每cfs_quota_us毫秒能使用cfs_period_us毫秒的CPU时间</p><ol><li>最多只能使用1个CPU（每250ms最多能使用250ms的CPU时间）</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 250000 &gt; cpu.cfs_quota_us /* quota = 250ms */</span></span><br><span class="line"><span class="comment"># echo 250000 &gt; cpu.cfs_period_us /* period = 250ms */</span></span><br></pre></td></tr></table></figure><ol><li>最多使用2个CPU（每500ms最多能使用1000ms的CPU时间，即使用两个内核）</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 1000000 &gt; cpu.cfs_quota_us /* quota = 1000ms */</span></span><br><span class="line"><span class="comment"># echo 500000 &gt; cpu.cfs_period_us /* period = 500ms */</span></span><br></pre></td></tr></table></figure><ol start="3"><li>最多使用1个CPU的20%（每50ms最多能使用10ms的CPU时间，即使用一个CPU核心的20%）</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 10000 &gt; cpu.cfs_quota_us /* quota = 10ms */</span></span><br><span class="line"><span class="comment"># echo 50000 &gt; cpu.cfs_period_us /* period = 50ms */</span></span><br></pre></td></tr></table></figure><h4 id="cpu使用时间相对值cpushares"><a class="markdownIt-Anchor" href="#cpu使用时间相对值cpushares"></a> CPU使用时间相对值：cpu.shares</h4><p>设置cgroup获得CPU轮转时间的相对值，默认值是1024。</p><p>假如系统中有两个cgroup，分别是A和B，A的shares值是1024，B的shares值是512，那么A将获得1024/(1204+512)=66%的CPU资源，而B将获得33%的CPU资源。</p><ul><li>如果A不忙，没有使用到66%的CPU时间，那么剩余的CPU时间将会被系统分配给B，即B的CPU使用率可以超过33%</li><li>如果添加了一个新的cgroup C，且它的shares值是1024，那么A的限额变成了1024/(1204+512+1024)=40%，B的变成了20%</li></ul><h4 id="cpu使用时间统计cpustat"><a class="markdownIt-Anchor" href="#cpu使用时间统计cpustat"></a> CPU使用时间统计：cpu.stat</h4><ul><li>nr_periods： 表示过去了多少个cpu.cfs_period_us里面配置的时间周期</li><li>nr_throttled： 在上面的这些周期中，有多少次是受到了限制（即cgroup中的进程在指定的时间周期中用光了它的配额）</li><li>throttled_time: cgroup中的进程被限制使用CPU持续了多长时间(纳秒)</li></ul></div><div id="current-post-cover" data-scr="/img/cart_cover.jpg"></div><div class="investment-container"><div class="investment-header"><div class="investment-title-1"><div class="on">相关文章</div><div>评论</div><div>分享</div></div><div class="investment-title-2"><span><a href="javascript: window.scrollTo(0, 0);">返回顶部</a> <a href="/编程语言/Tex/Tex历史.html" title="TEX历史" rel="prev">&laquo;上一篇 </a><a href="/Docker/sane_behavior.html" title="【纯转载】下一代的CGroup" rel="next">下一篇&raquo;</a></span></div></div><div class="investment-content"><div class="investment-content-list"><div class="relate-post"><ul><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/sane_behavior.html" title="【纯转载】下一代的CGroup">【纯转载】下一代的CGroup</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 19日, 2020</p><p class="relate-post-content">原文上面，我们可以看到，CGroup的一些常用方法和相关的术语。一般来说，这样的设计在一般情况下还是没什么问题的，除了操作上的用户体验不是很好，但基本满足我们的一般需求了。不过，对此，有个叫Tejun Heo的同学非常不爽，他在Lin...</p></div><div class="relate-post-cover"><a href="/Docker/sane_behavior.html" title="【纯转载】下一代的CGroup"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="【纯转载】下一代的CGroup"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/namespace.html" title="namespace">namespace</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">引入：Linux上的资源隔离指令chrootchroot，即 change root directory，更改 root 目录。在 linux 系统中，系统默认的目录结构都是以/，即是以根 (root) 开始的。而在使用 chroo...</p></div><div class="relate-post-cover"><a href="/Docker/namespace.html" title="namespace"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="namespace"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/AUFS.html" title="AUFS技术">AUFS技术</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">教程参考AUFS是一种联合文件系统 (Union File System, UnionFS, UFS)。AUFS又叫Another UnionFS，后来叫Alternative UnionFS，后来可能觉得不够霸气，叫成Advance...</p></div><div class="relate-post-cover"><a href="/Docker/AUFS.html" title="AUFS技术"><img class="lazy" src="/img/placeholder.jpg" data-src="/Docker/i/AUFS和Docker.png" alt="AUFS技术"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/namespaces/Network.html" title="Network namespace">Network namespace</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">Linux 虚拟网络设备 TUN/TAPTUN 设备是一种虚拟网络设备，通过此设备，程序可以方便得模拟网络行为。对于物理设备，其协议栈从物理网卡中读写数据：而TUN 设备的协议栈从文件中读写数据：所有对这个文件的写操作会通过 TUN...</p></div><div class="relate-post-cover"><a href="/Docker/namespaces/Network.html" title="Network namespace"><img class="lazy" src="/img/placeholder.jpg" data-src="/Docker/namespaces/../i/Linux虚拟网络设备.png" alt="Network namespace"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/namespaces/PIDandIPC.html" title="PID namespace">PID namespace</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">内核为所有的PID namespace维护了一个树状结构，最顶层的是系统初始时创建的，我们称之为root namespace。他创建的新PID namespace就称之为child namespace（树的子节点），而原先的PID n...</p></div><div class="relate-post-cover"><a href="/Docker/namespaces/PIDandIPC.html" title="PID namespace"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="PID namespace"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/namespaces/UTSandUser.html" title="UTS(UNIX Time-sharing System) namespace">UTS(UNIX Time-sharing System) namespace</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">Uts_namespace分析 UTS是什么当前一个系统的uts是linux主机所用的操作系统的版本、硬件名称等基本信息。uts信息在操作系统内核中定义为一个结构体,其值可以通过一些set*函数设置：12345678struct ne...</p></div><div class="relate-post-cover"><a href="/Docker/namespaces/UTSandUser.html" title="UTS(UNIX Time-sharing System) namespace"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="UTS(UNIX Time-sharing System) namespace"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/namespaces/Mount.html" title="Mount namespace">Mount namespace</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">它是历史上第一个Linux namespace，所以它的标识位比较特殊，就是CLONE_NEWNS。Mount namespace通过隔离文件系统挂载点对隔离文件系统提供支持，当我们使用 clone 函数或 unshare 函数并传入...</p></div><div class="relate-post-cover"><a href="/Docker/namespaces/Mount.html" title="Mount namespace"><img class="lazy" src="/img/placeholder.jpg" data-src="/Docker/namespaces/../i/mountnamespace.png" alt="Mount namespace"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/原理概述.html" title="Docker原理概述">Docker原理概述</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 六月 18日, 2020</p><p class="relate-post-content">Any problem in computer science can be solved by another layer of indirection.计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。基础教程VMWa...</p></div><div class="relate-post-cover"><a href="/Docker/原理概述.html" title="Docker原理概述"><img class="lazy" src="/img/placeholder.jpg" data-src="/Docker/i/虚拟机架构.png" alt="Docker原理概述"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/Docker-proxy.html" title="Docker 代理总结">Docker 代理总结</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 十二月 18日, 2019</p><p class="relate-post-content">为docker pull设置代理给docker pull意味着通过代理下载镜像。 在windows上docker desktop上的proxies设置就是设置的docker pull代理。默认情况下是10.0.75.1而不是127....</p></div><div class="relate-post-cover"><a href="/Docker/Docker-proxy.html" title="Docker 代理总结"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="Docker 代理总结"></a></div></li><li><div class="relate-post-text"><a class="relate-post-title" href="/Docker/Dockerfile补充知识.html" title="Dockerfile的一些补充知识">Dockerfile的一些补充知识</a><p class="relate-post-date"><i class="fa fa-calendar"></i> 十二月 3日, 2019</p><p class="relate-post-content">向进程发送停止信号默认情况下，docker容器在停止时会向容器内的1号进程发送SIGTERM信号告知应用停止。在命令行运行docker容器时，在容器stdout输出界面（docker run不加-d）中Ctrl+C就是向1号进程发送...</p></div><div class="relate-post-cover"><a href="/Docker/Dockerfile补充知识.html" title="Dockerfile的一些补充知识"><img class="lazy" src="/img/placeholder.jpg" data-src="/img/cart_cover.jpg" alt="Dockerfile的一些补充知识"></a></div></li></ul></div></div><div class="investment-content-list"><div class="layout-comment"><div>Please check the comment setting in config.yml of hexo-theme-Annie!</div></div></div><div class="investment-content-list"><div class="layout-share"><div class="social-share"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"><script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></div></div></div></div></div></div><script src="/plugin/clipboard/clipboard.js"></script><script>function codePreprocessing(){$("#article-content .highlight").each(function(){$(this).wrap('<div id="post-code"></div>')}),$("#article-content #post-code").each(function(){$(this).prepend('<nav class="copy-nav"><span><i class="code-language"></i></span></nav>')}),$("#article-content .copy-nav").each(function(){var t=$(this).next().attr("class"),e=9<t.length&&null!=t?t.substr(10):"none";$(this).find(".code-language").text(e),$(this).append('<span class="copy-btn"><i class="fa fa-copy" aria-hidden="true"></i></span>')})}function codeCopy(){$("#article-content #post-code").each(function(t){var e="codeCopy-"+t,n=$(this).find(".code"),o=$(this).find(".copy-btn");n.attr("id",e),o.attr("data-clipboard-target-id",e)});var t=new ClipboardJS(".copy-btn",{target:function(t){return document.getElementById(t.getAttribute("data-clipboard-target-id"))}});t.on("success",function(t){var e;t.clearSelection(),console.info("Action:",t.action),console.info("Trigger:",t.trigger),(e=t.trigger).setAttribute("aria-label","Copied!"),e.setAttribute("class","copy-btn copy-status"),setTimeout(function(){e.setAttribute("class","copy-btn")},2e3)}),t.on("error",function(t){console.error("Action:",t.action),console.error("Trigger:",t.trigger)})}$(".layout-post").length&&(codePreprocessing(),codeCopy())</script><link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css"><script src="/plugin/fancybox/jquery.fancybox.js"></script><script type="text/javascript">var titleID=$(".article-title a"),imageID=$(".article-content img"),videoID=$(".article-content video"),postTitle=titleID.text()?titleID.text():"No post title!";imageID.each(function(){var t=$(this).attr("src"),a=$(this).attr("alt")?$(this).attr("alt"):"No image description!";$(this).wrap('<a data-fancybox="gallery" data-caption=" 《 '+postTitle+" 》 "+a+' "  href=" '+t+' "> </a>')}),videoID.each(function(){var t=$(this).attr("src");$(this).wrap('<a data-fancybox href=" '+t+' "> </a>')}),$("#layout-post").length&&$('[data-fancybox="gallery"]').fancybox({loop:!0,buttons:["zoom","share","slideShow","fullScreen","thumbs","close"],protect:!1})</script></main><footer><div class="social"><ul><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-github"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-pinterest"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-instagram"></i></a></li><li><a href="http://github.com/yindaheng98" target="_blank"><i class="fa fa-twitter"></i></a></li><li><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li></ul></div><div class="copyright"><p>&copy;2017 - 2020, content by Howard Yin. All Rights Reserved.<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次</span></p><p><a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay. <a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> <a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a></p></div></footer><script src="/plugin/motto/motto.js"></script><script type="text/javascript">$(".motto").html(getMingYanContent())</script><div id="totop"><a href="javascript:;" name="TOTOP" class="fa fa-arrow-up"></a></div><script src="/plugin/vibrant/vibrant.js"></script><script src="/plugin/chinese/chinese.js"></script><script src="/plugin/imgLazyLoader/yall.min.js"></script><script src="/plugin/imgResize/jquery.resizeimagetoparent.min.js"></script><script src="/plugin/nicescroll/jquery.nicescroll.js"></script><script src="/js/resizediv.js"></script><script src="/js/main.js"></script><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></body></html>